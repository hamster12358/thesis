# -*- coding: utf-8 -*-
"""CLIP-LSTM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15hCMqmpiQg90Nmtyk8HavxxJppxtlF9i
"""

from tensorflow import keras
from imutils import paths

import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision.models as models
import torchvision.transforms as transforms
from torch.utils import data
from PIL import Image
import pandas as pd
import numpy as np
import imageio
import cv2
import os
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.metrics import balanced_accuracy_score
from sklearn.metrics import f1_score
from sklearn.preprocessing import OneHotEncoder, LabelEncoder
import pickle

import clip

# 加载clip
device = "cuda" if torch.cuda.is_available() else "cpu"
clip_model, preprocess = clip.load('ViT-B/32', device)

# 读取数据
data_dir = "./original"  # 设置自己路径
vedio_path = []
labels = []
res_size = 224

i = 0
for root, dirs, files in os.walk(data_dir):
    for file in files:
        path = os.path.join(root, file)
        label_pt = torch.tensor(i - 1)
        labels.append(label_pt)
        vedio_path.append(path)
    i += 1

#print(labels)
#print(vedio_path)

# train, test split
train_list, test_list, train_label, test_label = train_test_split(vedio_path, labels, test_size=0.1, random_state=2)

transform = preprocess
max_frames = 30


# 读取视频并抽取帧数
def get_center_image(frame):
    y, x = frame.shape[0:2]
    min_dim = min(y, x)
    start_x = (x // 2) - (min_dim // 2)
    start_y = (y // 2) - (min_dim // 2)

    return frame[start_y: start_y + min_dim, start_x: start_x + min_dim]


# 加载视频
def load_video(path, max_frames=0, use_transform=None, skip=20):
    # 跳帧读取，连续帧数效果一般
    cap = cv2.VideoCapture(path)
    frames = []
    i = 0
    try:
        while True:
            if i % skip == 0:
                ret, frame = cap.read()
                if not ret:
                    break
                frame = get_center_image(frame)
                frame = Image.fromarray(frame)

                if use_transform is not None:
                    frame = use_transform(frame)

                frames.append(frame)

                if len(frames) == max_frames:
                    break
                i += 1
            else:
                i += 1
                continue

    finally:
        cap.release()
    return frames


# 读取数据
class Dataset(data.Dataset):
    "Characterizes a dataset for PyTorch"

    def __init__(self, data_path, labels, max_frames, transform=None):
        # max_frames 设置需要读取的帧数
        # 初始化
        self.data_path = data_path
        self.labels = labels
        self.transform = transform
        self.frames = max_frames

    def __len__(self):
        "Denotes the total number of samples"
        return len(self.data_path)

    def read_images(self, path, use_transform):
        X = load_video(path, self.frames, use_transform)
        X = torch.stack(X, dim=0)

        return X

    def __getitem__(self, index):
        "Generates one sample of data"
        # 选择视频
        path = self.data_path[index]

        # 加载视频
        X = self.read_images(path, self.transform)  # (input) spatial images
        y = torch.LongTensor([self.labels[index]])  # (labels) LongTensor are for int64 instead of FloatTensor

        # print(X.shape)
        return X, y


train_set = Dataset(train_list, train_label, max_frames, transform=transform)
valid_set = Dataset(test_list, test_label, max_frames, transform=transform)

save_model_path = "./clipmodel"  # 设置保存模型路径

# RNN模型参数
RNN_hidden_layers = 3
RNN_hidden_nodes = 512
RNN_FC_dim = 256

# 训练参数
k = 5  # 类别数
epochs = 50  # 训练迭代
batch_size = 30
learning_rate = 1e-3  # 学习率
log_interval = 1  # 每10次迭代显示一次信息

# 选用GPU
use_cuda = torch.cuda.is_available()
device = torch.device("cuda" if use_cuda else "cpu")

params = {'batch_size': batch_size, 'shuffle': True, 'num_workers': 4, 'pin_memory': True} if use_cuda else {}

train_loader = data.DataLoader(train_set, **params)
valid_loader = data.DataLoader(valid_set, **params)


class LSTM(nn.Module):
    def __init__(self, CLIP_embed=512, h_RNN_layers=3, h_RNN=256, h_FC_dim=128, drop_p=0.3, num_classes=5):
        super(LSTM, self).__init__()

        self.RNN_input_size = CLIP_embed
        self.h_RNN_layers = h_RNN_layers  # RNN hidden layers
        self.h_RNN = h_RNN  # RNN hidden nodes
        self.h_FC_dim = h_FC_dim
        self.drop_p = drop_p
        self.num_classes = num_classes

        self.LSTM = nn.LSTM(
            input_size=self.RNN_input_size,
            hidden_size=self.h_RNN,
            num_layers=h_RNN_layers,
            batch_first=True,  # input & output will has batch size as 1s dimension. e.g. (batch, time_step, input_size)
        )

        self.fc1 = nn.Linear(self.h_RNN, self.h_FC_dim)
        self.fc2 = nn.Linear(self.h_FC_dim, self.num_classes)

    def forward(self, x_RNN):
        self.LSTM.flatten_parameters()
        RNN_out, (h_n, h_c) = self.LSTM(x_RNN, None)
        """ h_n shape (n_layers, batch, hidden_size), h_c shape (n_layers, batch, hidden_size) """
        """ None represents zero initial hidden state. RNN_out has shape=(batch, time_step, output_size) """

        # FC layers
        x = self.fc1(RNN_out[:, -1, :])  # choose RNN_out at the last time step
        x = F.relu(x)
        self.x_tsne = F.dropout(x, p=self.drop_p, training=self.training)
        x = self.fc2(self.x_tsne)

        return x


vedio = train_loader.dataset.__getitem__(0)


def train(log_interval, model, device, train_loader, optimizer, epoch):
    # 训练模型函数
    clip_model, rnn_decoder = model
    rnn_decoder.train()

    losses = []
    scores = []
    N_count = 0  # 已经训练过的视频
    for batch_idx, (X, y) in enumerate(train_loader):

        # 用CLIP提取特征
        all_features = []
        with torch.no_grad():
            for vedio in X:
                features = clip_model.encode_image(vedio.to(device))

                all_features.append(features)

        x = torch.stack(all_features).float().to(device)
        y = y.to(device).view(-1, )

        N_count += x.size(0)

        optimizer.zero_grad()

        output = rnn_decoder(x)  # 输出

        loss = F.cross_entropy(output, y)
        losses.append(loss.item())

        # to compute accuracy
        y_pred = torch.max(output, 1)[1]  # y_pred != output
        accu_score = accuracy_score(y.cpu().data.squeeze().numpy(), y_pred.cpu().data.squeeze().numpy())
        balanced_score = balanced_accuracy_score(y.cpu().data.squeeze().numpy(), y_pred.cpu().data.squeeze().numpy())
        f1 = f1_score(y.cpu().data.squeeze().numpy(), y_pred.cpu().data.squeeze().numpy(), average="macro")
        weighted_f1 = f1_score(y.cpu().data.squeeze().numpy(), y_pred.cpu().data.squeeze().numpy(), average="weighted")
        step_score = [accu_score, balanced_score, f1, weighted_f1]
        scores.append(step_score)  # computed on CPU        # computed on CPU

        loss.backward()
        optimizer.step()

        # log信息
        if (batch_idx + 1) % log_interval == 0:
            print(
                'Train Epoch: {} [{}/{} ({:.0f}%)]\tLoss: {:.6f}, Accu: {:.2f}%, Weighted Accu: {:.2f}%, F1: {:.2f}%, Weighted F1: {:.2f}%'.format(
                    epoch + 1, N_count, len(train_loader.dataset), 100. * (batch_idx + 1) / len(train_loader),
                    loss.item(), 100 * step_score[0], 100 * step_score[1], 100 * step_score[2], 100 * step_score[3]))

    return losses, scores


def validation(model, device, optimizer, test_loader):
    # 测试模型函数
    clip_model, rnn_decoder = model
    rnn_decoder.eval()

    test_loss = 0
    all_y = []
    all_y_pred = []
    all_tsne = []
    with torch.no_grad():
        for X, y in test_loader:
            all_features = []
            with torch.no_grad():
                for vedio in X:
                    features = clip_model.encode_image(vedio.to(device))

                    all_features.append(features)

            x = torch.stack(all_features).float().to(device)
            y = y.to(device).view(-1, )

            output = rnn_decoder(x)
            output_tsne = rnn_decoder.x_tsne
            loss = F.cross_entropy(output, y, reduction='sum')
            test_loss += loss.item()  # 计算loss
            y_pred = output.max(1, keepdim=True)[1]  # (y_pred != output) get the index of the max log-probability

            # 收集全部预测类别
            all_y.extend(y)
            all_y_pred.extend(y_pred)
            all_tsne.extend(output_tsne)

    test_loss /= len(test_loader.dataset)

    # 计算准确度
    all_y = torch.stack(all_y, dim=0)
    all_y_pred = torch.stack(all_y_pred, dim=0)
    all_tsne = torch.stack(all_tsne, dim=0)

    accu_score = accuracy_score(all_y.cpu().data.squeeze().numpy(), all_y_pred.cpu().data.squeeze().numpy())
    balanced_score = balanced_accuracy_score(all_y.cpu().data.squeeze().numpy(),
                                             all_y_pred.cpu().data.squeeze().numpy())
    f1 = f1_score(all_y.cpu().data.squeeze().numpy(), all_y_pred.cpu().data.squeeze().numpy(), average="macro")
    weighted_f1 = f1_score(all_y.cpu().data.squeeze().numpy(), all_y_pred.cpu().data.squeeze().numpy(),
                           average="weighted")
    test_score = [accu_score, balanced_score, f1, weighted_f1]

    # log信息
    print(
        '\nTest set ({:d} samples): Average loss: {:.4f}, Accuracy: {:.2f}%, Weighted Accuracy: {:.2f}%, F1: {:.2f}%, Weighted F1: {:.2f}%\n'.format(
            len(all_y), test_loss, 100 * test_score[0], 100 * test_score[1], 100 * test_score[2], 100 * test_score[3]))
    datas = 'Average loss: ' + str(test_loss) + ' Accuracy: ' + str(100 * test_score[0]) + ' Weighted Accuracy: ' + str(
        100 * test_score[1]) + ' F1: ' + str(100 * test_score[2]) + ' Weighted F1: ' + str(100 * test_score[3])

    with open('clipdatas.txt', 'a', encoding='utf-8') as f:
        f.write(datas)
        f.write('\n')
        f.close()
    # save Pytorch models of best record
    if (epoch + 1) % 5 == 0:
        torch.save(rnn_decoder.state_dict(),
                   os.path.join(save_model_path, 'rnn_decoder_epoch{}.pth'.format(epoch + 1)))  # save motion_encoder
        torch.save(optimizer.state_dict(),
                   os.path.join(save_model_path, 'optimizer_epoch{}.pth'.format(epoch + 1)))  # save optimizer
        print("Epoch {} model saved!".format(epoch + 1))

    return test_loss, test_score, all_y, all_y_pred, all_tsne


rnn_decoder = LSTM(CLIP_embed=512, h_RNN_layers=RNN_hidden_layers, h_RNN=RNN_hidden_nodes,
                   h_FC_dim=RNN_FC_dim, drop_p=0.2, num_classes=k).to(device)

# 平行运行
if torch.cuda.device_count() > 1:
    print("Using", torch.cuda.device_count(), "GPUs!")
    rnn_decoder = nn.DataParallel(rnn_decoder)

elif torch.cuda.device_count() == 1:
    print("Using", torch.cuda.device_count(), "GPU!")

rnn_params = list(rnn_decoder.parameters())

optimizer = torch.optim.Adam(rnn_params, lr=learning_rate)

# 记录训练数据
epoch_train_losses = []
epoch_train_scores = []
epoch_test_losses = []
epoch_test_scores = []

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.manifold import TSNE
import seaborn as sns
import itertools
def plt_tsne(gt_labels, pred_labels):
    tsne = TSNE(n_components=2, perplexity=5)
    X_tsne = tsne.fit_transform(pred_labels)
    X_tsne_data = np.vstack((X_tsne.T, gt_labels)).T
    df_tsne = pd.DataFrame(X_tsne_data, columns=['Dim1', 'Dim2', 'class'])
    plt.figure(figsize=(8, 8))
    sns.scatterplot(data=df_tsne, hue='class', x='Dim1', y='Dim2')
    plt.savefig('clip_lstm_tsne.jpg')

def plot_confusion_matrix(gt_labels, pred_labels, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    Input
    - cm : 计算出的混淆矩阵的值
    - classes : 混淆矩阵中每一行每一列对应的列
    - normalize : True:显示百分比, False:显示个数
    """
    cm = confusion_matrix(gt_labels, pred_labels)
    print("confusion_mat.shape : {}".format(cm.shape))
    print("confusion_mat : {}".format(cm))

    if normalize:
        matrix = cm
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')
    plt.figure()
    # 设置输出的图片大小
    figsize = 8, 8
    figure, ax = plt.subplots(figsize=figsize)
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    # 设置title的大小以及title的字体
    font_title = {'family': 'Times New Roman',
                  'weight': 'normal',
                  'size': 15,
                  }
    plt.title(title, fontdict=font_title)
    plt.colorbar()
    # tick_marks = np.arange(len(classes))
    # plt.xticks(tick_marks, classes, rotation=45, )
    # plt.yticks(tick_marks, classes)
    # 设置坐标刻度值的大小以及刻度值的字体
    plt.tick_params(labelsize=15)
    labels = ax.get_xticklabels() + ax.get_yticklabels()
    print(labels)
    [label.set_fontname('Times New Roman') for label in labels]
    if normalize:
        fm_int = 'd'
        fm_float = '.2%'
        thresh = cm.max() / 2.
        for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
            plt.text(j, i, format(cm[i, j], fm_float),
                     horizontalalignment="center", verticalalignment='bottom', family="Times New Roman",
                     weight="normal", size=15,
                     color="white" if cm[i, j] > thresh else "black")
            plt.text(j, i, format(matrix[i, j], fm_int),
                     horizontalalignment="center", verticalalignment='top', family="Times New Roman", weight="normal",
                     size=15,
                     color="white" if cm[i, j] > thresh else "black")
    else:
        fm_int = 'd'
        thresh = cm.max() / 2.
        for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
            plt.text(j, i, format(cm[i, j], fm_int),
                     horizontalalignment="center", verticalalignment='bottom',
                     color="white" if cm[i, j] > thresh else "black")

    plt.tight_layout()

    plt.savefig('clip_lstm_cm.jpg')

# 开始训练
if __name__ == '__main__':
    for epoch in range(epochs):
        # 训练和验证模型
        train_losses, train_scores = train(log_interval, [clip_model, rnn_decoder], device, train_loader, optimizer, epoch)
        epoch_test_loss, epoch_test_score,all_y, all_y_pred, all_tsne = validation([clip_model, rnn_decoder], device, optimizer, valid_loader)

        # 记录结果
        epoch_train_losses.append(train_losses)
        epoch_train_scores.append(train_scores)
        epoch_test_losses.append(epoch_test_loss)
        epoch_test_scores.append(epoch_test_score)

    plot_confusion_matrix(all_y.cpu(), all_y_pred.cpu()[:, 0])
    plt_tsne(all_y.cpu(),all_tsne.cpu())
